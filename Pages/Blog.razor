@page "/blog"
@using Monydragons_Portfolio.Services.Utility.Interface
@inject IBlogService BlogService
@inject IContentService BlogContentService
@inject IFilteringSortingService FilteringSortingService
@inject IPaginationService PaginationService
@inject IPollingService PollingService
@inject IJSRuntime JSRuntime
@implements IDisposable


<div class="header-container">
    <div class="sticky-header">
        <h1>Mony Dragon's Development Blog</h1>
    </div>
    <div class="search-area @collapsedClass">
        @if (showSearch)
        {
            <input type="text" class="search-input-large search-input-expanded" @bind="searchTerm" @oninput="OnSearchTermChanged" placeholder="Search posts..." />
            <button class="button primary large" @onclick="ToggleSortingOrder">@($"{(sortingOrder ? "Descending" : "Ascending")}")</button>
        }
        <div class="icons-container">
            <button @onclick="ToggleSearch" class="search-toggle"><i class="fa fa-search"></i></button>
            <button @onclick="ForceRefreshPosts" class="refresh-button"><i class="fas fa-sync"></i></button>
        </div>

    </div>
</div>


<div class="blog-container">
@if (allPosts == null)
{
    <p>Loading...</p>
}
else
{
    @foreach (var post in displayedPosts)
    {
        <div class="blog-post">
            <h2>@BlogContentService.Linkify(BlogContentService.GetTitleWithoutDate(post.Title))</h2>
            <p><em>@post.Date.ToString("yyyy-MM-dd")</em></p>
            @foreach (var content in post.ContentFiles)
            {
                <pre>@BlogContentService.ProcessContent(content)</pre>

            }
            @foreach (var imageFile in post.ImageFiles)
            {
                <img src="@imageFile" alt="Blog Image" />
            }
        </div>
    }
    @if (isPaginationEnabled)
    {
        <nav aria-label="Page navigation" class="pagination-wrapper">
            <ul class="pagination-controls">
                <li class="page-item first-page">
                    <button class="page-link" @onclick="GoToFirstPage" disabled="@FirstPageDisabled">
                        <i class="fa fa-angle-double-left"></i>
                    </button>
                </li>
                <li class="page-item">
                    <button class="page-link" @onclick="GoToPreviousPage" disabled="@PreviousPageDisabled">
                        <i class="fa fa-angle-left"></i>
                    </button>
                </li>

                @foreach (var pageNumber in GetPageNumbers())
                {
                    <li class="@(currentPage == pageNumber ? "active" : "") @(IsAdjacent(pageNumber) ? "adjacent" : "")">
                        <button class="page-link" @onclick="@(() => GoToPage(pageNumber))">@pageNumber</button>
                    </li>
                }

                <li class="page-item">
                    <button class="page-link" @onclick="GoToNextPage" disabled="@NextPageDisabled">
                        <i class="fa fa-angle-right"></i>
                    </button>
                </li>
                <li class="page-item last-page">
                    <button class="page-link" @onclick="GoToLastPage" disabled="@LastPageDisabled">
                        <i class="fa fa-angle-double-right"></i>
                    </button>
                </li>
            </ul>
        </nav>
    }
    @if (!isPaginationEnabled && morePostsAvailable)
    {
        <button @onclick="LoadMorePosts" class="button primary large load-more spaced-button">Load More</button>
    }
    
    <button @onclick="TogglePagination" class="button primary large toggle-pagination spaced-button">@TogglePaginationText</button>
    
}
</div>

@code {
    private IEnumerable<BlogPost> allPosts; // This holds all your posts
    private IEnumerable<BlogPost> filteredPosts; // This holds filtered results or all posts if no filter
    private IEnumerable<BlogPost> displayedPosts; // This holds currently displayed posts (paginated)
    private bool sortingOrder = true; // true for Descending, false for Ascending
    private string searchTerm = "";
    private bool showSearch; // Controls the visibility of the search box
    private int pageSize = 10;
    private int currentPage = 1;
    private int totalPages; // Dynamically calculated based on the number of posts
    private int visiblePageLinks = 5; // Number of visible page links
    
    private bool isPaginationEnabled = true;
    private string TogglePaginationText => isPaginationEnabled ? "Disable Pagination" : "Enable Pagination";
    private string collapsedClass => !showSearch ? "collapsed" : "expanded";

    private bool isFiltered = false;

    private bool FirstPageDisabled => currentPage == 1;
    private bool PreviousPageDisabled => currentPage == 1;
    private bool NextPageDisabled => currentPage == totalPages;
    private bool LastPageDisabled => currentPage == totalPages;
    
    private bool isMobileScreen;
    
    private bool isLoadingMorePosts;
    private bool morePostsAvailable = true; // Initialize to true


    protected override async Task OnInitializedAsync()
    {
        PollingService.StartPolling(TimeSpan.FromMinutes(1), RefreshPosts);
        await RefreshPosts();
    }
    
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isMobileScreen = await JSRuntime.InvokeAsync<bool>("siteUtility.isMobile");
            await JSRuntime.InvokeVoidAsync("siteUtility.scrollToTop");
        }
    }
    
    private async Task RefreshPosts()
    {
        var fetchedPosts = await BlogService.GetBlogPostsAsync();

        // Apply initial sorting based on the current sorting order.
        var sortedPosts = sortingOrder ? fetchedPosts.OrderByDescending(post => post.Date) : fetchedPosts.OrderBy(post => post.Date);

        // Assign sorted posts to allPosts
        allPosts = sortedPosts;

        // Apply content loading for all posts (this could be optimized based on actual usage scenario)
        foreach (var post in allPosts)
        {
            var contents = new List<string>();
            foreach (var contentFile in post.ContentFiles)
            {
                var content = await BlogService.GetContentFileAsync(contentFile);
                contents.Add(content);
            }
            post.ContentFiles = contents;
        }

        // If there is a search term, apply the filter; otherwise, display all posts.
        if (!string.IsNullOrEmpty(searchTerm))
        {
            isFiltered = true;
            // Apply the filter based on the current search term.
            // Make sure FilteringSortingService.ApplyFiltersAsync can handle empty or null searchTerm appropriately
            filteredPosts = await FilteringSortingService.ApplyFiltersAsync(allPosts, searchTerm);
            filteredPosts = sortingOrder ? filteredPosts.OrderByDescending(post => post.Date) : filteredPosts.OrderBy(post => post.Date);
        }
        else
        {
            isFiltered = false;
            filteredPosts = allPosts;
        }

        // Always reset to the first page after a refresh and apply pagination on the filtered or all posts.
        currentPage = 1;
        ApplyPagination();
    }
    
    private async Task ForceRefreshPosts()
    {
        await JSRuntime.InvokeVoidAsync("siteUtility.refreshPage");
        await RefreshPosts();
    }
    
    private async Task LoadMorePosts()
    {
        if (isLoadingMorePosts)
        {
            return; // Already in the process of loading more posts.
        }

        isLoadingMorePosts = true;

        if (!isPaginationEnabled)
        {
            var additionalPosts = isFiltered ? filteredPosts.Skip(displayedPosts.Count()).Take(pageSize) 
                : allPosts.Skip(displayedPosts.Count()).Take(pageSize);
            displayedPosts = displayedPosts.Concat(additionalPosts).ToList();
        
            morePostsAvailable = displayedPosts.Count() < (isFiltered ? filteredPosts.Count() : allPosts.Count());
        }
        else
        {
            // If pagination is somehow re-enabled, this ensures it behaves correctly.
            currentPage++;
            ApplyPagination();
        }

        isLoadingMorePosts = false;
        StateHasChanged(); // Refresh the UI with the newly loaded posts.
    }
    
    private async Task OnSearchTermChanged(ChangeEventArgs e)
    {
        searchTerm = e.Value.ToString();
        await ApplyFilters();
    }
    
    private async Task ToggleSortingOrder()
    {
        sortingOrder = !sortingOrder;
        await ApplyFilters(); // Reapply filters with the new sort order
    }
    
    private void ToggleSearch()
    {
        showSearch = !showSearch;
        StateHasChanged(); // This line might be optional in Blazor Server, but just to ensure UI updates.
    }
    
    private async Task ApplyFilters()
    {
        if (string.IsNullOrEmpty(searchTerm))
        {
            isFiltered = false;
            filteredPosts = allPosts;
        }
        else
        {
            isFiltered = true;
            // Assuming ApplyFiltersAsync and SortPostsAsync are your methods that need to be implemented
            filteredPosts = await FilteringSortingService.ApplyFiltersAsync(allPosts, searchTerm);
            if(sortingOrder)
            {
                filteredPosts = filteredPosts.OrderByDescending(post => post.Date);
            }
            else
            {
                filteredPosts = filteredPosts.OrderBy(post => post.Date);
            }
        }

        currentPage = 1;
        ApplyPagination();
    }

    private void ApplyPagination()
    {
        var datasetToPaginate = isFiltered ? filteredPosts : allPosts;
        var paginationResult = PaginationService.Paginate(datasetToPaginate, currentPage, pageSize);
        displayedPosts = paginationResult.Items;
        totalPages = paginationResult.TotalPages;

        StateHasChanged();
    }
    
    private async void GoToFirstPage()
    {
        currentPage = 1;
        ApplyPagination();
        await JSRuntime.InvokeVoidAsync("siteUtility.scrollToTop");
    }
    
    private async void GoToLastPage()
    {
        currentPage = totalPages;
        ApplyPagination();
        await JSRuntime.InvokeVoidAsync("siteUtility.scrollToTop");
    }


    private async void GoToPreviousPage()
    {
        if (currentPage > 1)
        {
            currentPage--;
            ApplyPagination();
            await JSRuntime.InvokeVoidAsync("siteUtility.scrollToTop");
        }
    }

    private async void GoToNextPage()
    {
        if (currentPage < totalPages)
        {
            currentPage++;
            ApplyPagination();
            await JSRuntime.InvokeVoidAsync("siteUtility.scrollToTop");
        }
    }

    private async void GoToPage(int pageNumber)
    {
        if (pageNumber >= 1 && pageNumber <= totalPages && pageNumber != currentPage)
        {
            currentPage = pageNumber;
            ApplyPagination();
            await JSRuntime.InvokeVoidAsync("siteUtility.scrollToTop");
        }
    }
    
    private async void TogglePagination()
    {
        isPaginationEnabled = !isPaginationEnabled;

        if (!isPaginationEnabled)
        {
            var postsToLoad = currentPage * pageSize;
            var posts = isFiltered ? filteredPosts : allPosts;
            displayedPosts = posts.Take(postsToLoad).ToList();
            morePostsAvailable = displayedPosts.Count() < posts.Count();
        }
        else
        {
            ApplyPagination();
        }

        StateHasChanged(); // This triggers a re-render
    }
    
    private bool IsAdjacent(int pageNumber)
    {
        int adjacentRange = isMobileScreen ? 1 : 2; // Adjust based on screen size
        return Math.Abs(currentPage - pageNumber) <= adjacentRange;
    }

    private IEnumerable<int> GetPageNumbers()
    {
        int startPage = Math.Max(1, currentPage - visiblePageLinks / 2);
        int endPage = Math.Min(totalPages, startPage + visiblePageLinks - 1);

        return Enumerable.Range(startPage, endPage - startPage + 1);
    }
    
    public void Dispose()
    {
        PollingService.StopPolling();
    }
}
